/*
 * Copyright (c) 2019 Nikos Nikoleris
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met: redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer;
 * redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution;
 * neither the name of the copyright holders nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Nikos Nikoleris
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

int main()
{
    char *filename = "input";
    char *argv[101];
    memset(argv, 0, sizeof argv);
    argv[0] = filename;

    int i;
    for (i = 1; i < 100; i++) {
            argv[i] = "foo";
    }
    argv['A'] = "\x00";
    argv['B'] = "\x20\x0a\x0d";
    argv['C'] = "18081";

    char *envp[101];
    memset(envp, 0, sizeof argv);
    envp[0] = "\xde\xad\xbe\xef=\xca\xfe\xba\xbe";

    FILE* fp = fopen("\x0a", "w");
    fwrite("\x00\x00\x00\x00", 4, 1, fp);
    fclose(fp);

    int pdes1[2];
    if(pipe(pdes1) == -1) {
        perror("pipe");
        exit(EXIT_FAILURE);
    }
    int pdes2[2];
    if(pipe(pdes2) == -1) {
        perror("pipe");
        exit(EXIT_FAILURE);
    }

    pid_t cpid = fork();
    if (cpid < 0) {
        perror("fork");
        exit(EXIT_FAILURE);
    }

    if (cpid == 0) {
        if (dup2(pdes1[0], 0) == -1) {
            perror("dup2");
            exit(EXIT_FAILURE);
        }
        close(pdes1[1]);
        if (dup2(pdes2[0], 2) == -1) {
            perror("dup2");
            exit(EXIT_FAILURE);
        }
        close(pdes2[1]);

        execve(filename, argv, envp);
        perror("execv");
        exit(EXIT_FAILURE);
    }
    close(pdes1[0]);
    close(pdes2[0]);
 
    write(pdes1[1], "\x00\x0a\x00\xff", 4);
    write(pdes2[1], "\x00\x0a\x02\xff", 4);

    // network
    int sd;
    struct sockaddr_in saddr;
    sd = socket(AF_INET, SOCK_STREAM, 0);
    if(sd == -1){
        printf("exploit: socket error, tell admin\n");
        exit(EXIT_FAILURE);
    }
    saddr.sin_family = AF_INET;
    if(inet_pton(AF_INET, "127.0.0.1", &saddr.sin_addr) <= 0) { 
        printf("exploit: Invalid address\n"); 
        exit(EXIT_FAILURE);
    }
    saddr.sin_port = htons(atoi(argv['C']));
    while (connect(sd, (struct sockaddr*)&saddr, sizeof(saddr)) < 0) {
    }
    printf("Connected\n");
    char buf[] = "\xde\xad\xbe\xef";
    send(sd, buf, 4, 0);

    pid_t rpid = wait(NULL);
    if (rpid != cpid) {
        fprintf(stderr, "Child %d is still alive\n", cpid);
    }

    return 0;
}
